import logging
import feedparser
import httpx
import re
import json
import os
import asyncio
from functools import wraps
import threading
from flask import Flask, request, Response
import html
import sys
import xmltodict

from telegram import Update
from telegram.ext import Application, CommandHandler, CallbackContext
from telegram.constants import ParseMode

# --- C·∫§U H√åNH LOGGING ---
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)
# ------------------------------------

# --- C·∫§U H√åNH BOT T·ª™ BI·∫æN M√îI TR∆Ø·ªúNG ---
BOT_TOKEN = os.getenv('BOT_TOKEN')
CHAT_ID = os.getenv('CHAT_ID')
ADMIN_USER_ID_STR = os.getenv('ADMIN_USER_ID')
# !!! QUAN TR·ªåNG: S·ª¨A L·∫†I URL C·ª¶A B·∫†N TR√äN RENDER !!!
CALLBACK_URL = os.getenv('RENDER_EXTERNAL_URL', 'https://your-app-name.onrender.com') + "/youtube_webhook"
# ------------------------------------

if not all([BOT_TOKEN, CHAT_ID, ADMIN_USER_ID_STR]):
    logger.critical("L·ªñI: Thi·∫øu bi·∫øn m√¥i tr∆∞·ªùng b·∫Øt bu·ªôc: BOT_TOKEN, CHAT_ID, ADMIN_USER_ID")
    sys.exit(1)

ADMIN_USER_ID = int(ADMIN_USER_ID_STR)

# --- C·∫§U H√åNH JSONBIN.IO ---
JSONBIN_API_KEY = os.getenv('JSONBIN_API_KEY')
JSONBIN_BIN_ID = os.getenv('JSONBIN_BIN_ID')
JSONBIN_URL = f"https://api.jsonbin.io/v3/b/{JSONBIN_BIN_ID}"
# ------------------------------------

HUB_URL = "https://pubsubhubbub.appspot.com/subscribe"
state_lock = asyncio.Lock()
app = Flask(__name__)
application: Application = None # Bi·∫øn to√†n c·ª•c ƒë·ªÉ Flask c√≥ th·ªÉ truy c·∫≠p

# --- C√ÅC H√ÄM C·ª¶A BOT ƒê√É S·ª¨A L·ªñI ---
# (C√°c h√†m load_state, save_state, get_channel_id_from_url, start, help gi·ªØ nguy√™n nh∆∞ phi√™n b·∫£n tr∆∞·ªõc)

async def load_state(client: httpx.AsyncClient):
    headers = {'X-Master-Key': JSONBIN_API_KEY}
    try:
        response = await client.get(f"{JSONBIN_URL}/latest", headers=headers, timeout=15)
        response.raise_for_status()
        return response.json().get('record', {"channels": {}})
    except httpx.RequestError as e:
        logger.error(f"L·ªói khi ƒë·ªçc tr·∫°ng th√°i: {e}")
        return None

async def save_state(client: httpx.AsyncClient, state):
    headers = {'Content-Type': 'application/json', 'X-Master-Key': JSONBIN_API_KEY}
    try:
        data_to_save = json.dumps(state, ensure_ascii=False).encode('utf-8')
        response = await client.put(JSONBIN_URL, headers=headers, content=data_to_save, timeout=15)
        response.raise_for_status()
        logger.info("ƒê√£ l∆∞u tr·∫°ng th√°i th√†nh c√¥ng l√™n JSONBin.io")
        return True
    except httpx.RequestError as e:
        logger.error(f"L·ªói khi l∆∞u tr·∫°ng th√°i l√™n JSONBin: {e}")
        return False

async def get_channel_id_from_url(client: httpx.AsyncClient, channel_url):
    try:
        response = await client.get(channel_url, timeout=15, follow_redirects=True)
        response.raise_for_status()
        match = re.search(r'"channelId":"(UC[A-Za-z0-9_-]{22})"', response.text)
        if match: return match.group(1)
        else: return None
    except httpx.RequestError as e:
        logger.error(f"L·ªói khi l·∫•y Channel ID t·ª´ {channel_url}: {e}")
        return None

def restricted(func):
    @wraps(func)
    async def wrapped(update: Update, context: CallbackContext, *args, **kwargs):
        user_id = update.effective_user.id
        if user_id != ADMIN_USER_ID:
            await update.message.reply_text("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
            return
        return await func(update, context, *args, **kwargs)
    return wrapped

async def start(update: Update, context: CallbackContext):
    await update.message.reply_text("üëã Ch√†o b·∫°n! T√¥i l√† bot th√¥ng b√°o video YouTube, phi√™n b·∫£n Webhook t·ªëc ƒë·ªô cao.")

async def help_command(update: Update, context: CallbackContext):
    await update.message.reply_text("C√°c l·ªánh: /add, /remove, /list, /resubscribeall")

# --- LOGIC M·ªöI CHO WEBHOOKS ---

async def manage_subscription(channel_id: str, mode: str = "subscribe"):
    """G·ª≠i y√™u c·∫ßu ƒëƒÉng k√Ω ho·∫∑c h·ªßy ƒëƒÉng k√Ω ƒë·∫øn Hub."""
    topic_url = f"https://www.youtube.com/feeds/videos.xml?channel_id={channel_id}"
    data = {
        'hub.mode': mode,
        'hub.topic': topic_url,
        'hub.callback': CALLBACK_URL,
        'hub.verify': 'async',
        'hub.lease_seconds': 432000  # 5 ng√†y
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(HUB_URL, data=data)
            if 200 <= response.status_code < 300:
                logger.info(f"Y√™u c·∫ßu '{mode}' cho k√™nh {channel_id} ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng.")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i y√™u c·∫ßu '{mode}' cho k√™nh {channel_id}. Status: {response.status_code}, Body: {response.text}")
                return False
        except httpx.RequestError as e:
            logger.error(f"L·ªói m·∫°ng khi g·ª≠i y√™u c·∫ßu '{mode}': {e}")
            return False

async def process_notification(xml_data: bytes):
    """X·ª≠ l√Ω th√¥ng b√°o video m·ªõi t·ª´ Hub."""
    logger.info("ƒê√£ nh·∫≠n ƒë∆∞·ª£c th√¥ng b√°o t·ª´ Hub.")
    try:
        data = xmltodict.parse(xml_data)
        entry = data.get('feed', {}).get('entry')
        if not entry:
            logger.warning("Th√¥ng b√°o kh√¥ng ch·ª©a entry video.")
            return

        video_id = entry.get('yt:videoId')
        channel_id = entry.get('yt:channelId')

        if not video_id or not channel_id:
            logger.warning("Kh√¥ng t√¨m th·∫•y video_id ho·∫∑c channel_id trong th√¥ng b√°o.")
            return
            
        async with httpx.AsyncClient() as client:
            async with state_lock:
                state = await load_state(client)
                if state is None or channel_id not in state.get("channels", {}):
                    return

                last_known_id = state["channels"][channel_id].get("last_video_id")
                if last_known_id != video_id:
                    logger.info(f"Ph√°t hi·ªán video m·ªõi {video_id} cho k√™nh {channel_id}.")
                    channel_name = html.escape(state["channels"][channel_id].get('name', entry.get('author', {}).get('name')))
                    video_title = html.escape(entry.get('title'))
                    video_link = entry.get('link', {}).get('@href')

                    message = (f"üì∫ <b>{channel_name}</b> v·ª´a ra video m·ªõi!\n\n"
                               f"<b>{video_title}</b>\n\n"
                               f'<a href="{video_link}">Xem ngay t·∫°i ƒë√¢y</a>')

                    await application.bot.send_message(chat_id=CHAT_ID, text=message, parse_mode=ParseMode.HTML)
                    
                    state["channels"][channel_id]["last_video_id"] = video_id
                    await save_state(client, state)

    except Exception as e:
        logger.error(f"L·ªói nghi√™m tr·ªçng khi x·ª≠ l√Ω th√¥ng b√°o: {e}")

@app.route('/youtube_webhook', methods=['GET', 'POST'])
def webhook_endpoint():
    if request.method == 'GET':
        challenge = request.args.get('hub.challenge')
        if challenge:
            logger.info("X√°c th·ª±c webhook th√†nh c√¥ng v·ªõi Hub.")
            return Response(challenge, status=200, mimetype='text/plain')
        logger.warning("Y√™u c·∫ßu GET kh√¥ng c√≥ challenge.")
        return Response("No challenge", status=400, mimetype='text/plain')

    elif request.method == 'POST':
        # ƒê·∫©y vi·ªác x·ª≠ l√Ω sang lu·ªìng async c·ªßa bot
        application.create_task(process_notification(request.data))
        return Response("OK", status=200)

# --- C√ÅC L·ªÜNH ƒê√É C·∫¨P NH·∫¨T ---

@restricted
async def add_channel(update: Update, context: CallbackContext):
    if not context.args:
        await update.message.reply_text("Vui l√≤ng nh·∫≠p link k√™nh ho·∫∑c Channel ID.")
        return
    user_input = context.args[0]
    async with httpx.AsyncClient() as client:
        # T∆∞∆°ng t·ª± phi√™n b·∫£n tr∆∞·ªõc, nh∆∞ng th√™m b∆∞·ªõc subscribe
        async with state_lock:
            state = await load_state(client)
            if state is None: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi DB."); return
            channel_id, final_url = None, None
            if user_input.startswith("UC") and len(user_input) == 24:
                channel_id, final_url = user_input, f"https://www.youtube.com/channel/{user_input}"
            elif user_input.startswith("http"):
                final_url = user_input
                channel_id = await get_channel_id_from_url(client, user_input)
            else:
                await update.message.reply_text("‚ùå ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá."); return
            if not channel_id: await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y Channel ID."); return
            if channel_id in state["channels"]: await update.message.reply_text("‚úÖ K√™nh ƒë√£ c√≥ trong danh s√°ch."); return
            
            feed = await asyncio.to_thread(feedparser.parse, f'https://www.youtube.com/feeds/videos.xml?channel_id={channel_id}')
            channel_name = feed.feed.get('title', "T√™n kh√¥ng x√°c ƒë·ªãnh")
            
            state["channels"][channel_id] = {"url": final_url, "name": channel_name, "last_video_id": None}
            
            if await save_state(client, state):
                safe_channel_name = html.escape(channel_name)
                await update.message.reply_text(f"‚úÖ ƒê√£ th√™m k√™nh: <b>{safe_channel_name}</b>. ƒêang ti·∫øn h√†nh ƒëƒÉng k√Ω nh·∫≠n th√¥ng b√°o...", parse_mode=ParseMode.HTML)
                if await manage_subscription(channel_id, "subscribe"):
                    await update.message.reply_text(f"‚úÖ ƒêƒÉng k√Ω nh·∫≠n th√¥ng b√°o cho <b>{safe_channel_name}</b> th√†nh c√¥ng!", parse_mode=ParseMode.HTML)
                else:
                    await update.message.reply_text(f"‚ö†Ô∏è L·ªói khi ƒëƒÉng k√Ω nh·∫≠n th√¥ng b√°o cho <b>{safe_channel_name}</b>.", parse_mode=ParseMode.HTML)
            else:
                await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ l∆∞u thay ƒë·ªïi.")

@restricted
async def remove_channel(update: Update, context: CallbackContext):
    # T∆∞∆°ng t·ª± phi√™n b·∫£n tr∆∞·ªõc, nh∆∞ng th√™m b∆∞·ªõc unsubscribe
    if not context.args: await update.message.reply_text("Vui l√≤ng nh·∫≠p link/ID c·∫ßn x√≥a."); return
    user_input = context.args[0]
    async with httpx.AsyncClient() as client:
        async with state_lock:
            state = await load_state(client);
            if state is None: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi DB."); return
            channel_id_to_remove = None
            if user_input.startswith("UC") and len(user_input) == 24: channel_id_to_remove = user_input
            elif user_input.startswith("http"): channel_id_to_remove = await get_channel_id_from_url(client, user_input)
            else: await update.message.reply_text("‚ùå ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá."); return
            if not channel_id_to_remove: await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y k√™nh."); return
            if channel_id_to_remove in state["channels"]:
                channel_name = state["channels"][channel_id_to_remove].get('name', 'K√™nh kh√¥ng r√µ t√™n')
                del state["channels"][channel_id_to_remove]
                if await save_state(client, state):
                    safe_channel_name = html.escape(channel_name)
                    await update.message.reply_text(f"üóëÔ∏è ƒê√£ x√≥a k√™nh: <b>{safe_channel_name}</b>.", parse_mode=ParseMode.HTML)
                    await manage_subscription(channel_id_to_remove, "unsubscribe") # Kh√¥ng c·∫ßn ch·ªù k·∫øt qu·∫£
                else:
                    await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ l∆∞u thay ƒë·ªïi.")
            else:
                await update.message.reply_text("K√™nh n√†y kh√¥ng c√≥ trong danh s√°ch.")

@restricted
async def resubscribeall(update: Update, context: CallbackContext):
    """ƒêƒÉng k√Ω l·∫°i t·∫•t c·∫£ c√°c k√™nh, h·ªØu √≠ch ƒë·ªÉ gia h·∫°n."""
    await update.message.reply_text("B·∫Øt ƒë·∫ßu qu√° tr√¨nh ƒëƒÉng k√Ω l·∫°i cho t·∫•t c·∫£ c√°c k√™nh...")
    async with httpx.AsyncClient() as client:
        state = await load_state(client)
        if state is None or not state.get("channels"):
            await update.message.reply_text("Kh√¥ng c√≥ k√™nh n√†o ƒë·ªÉ ƒëƒÉng k√Ω l·∫°i.")
            return
        
        success_count = 0
        fail_count = 0
        for channel_id in state["channels"]:
            if await manage_subscription(channel_id, "subscribe"):
                success_count += 1
            else:
                fail_count += 1
            await asyncio.sleep(1) # Tr√°nh spam Hub
            
    await update.message.reply_text(f"Ho√†n t·∫•t! ƒêƒÉng k√Ω th√†nh c√¥ng: {success_count}, th·∫•t b·∫°i: {fail_count}.")

@restricted
async def list_channels(update: Update, context: CallbackContext):
    # Gi·ªØ nguy√™n nh∆∞ phi√™n b·∫£n tr∆∞·ªõc
    async with httpx.AsyncClient() as client:
        state = await load_state(client)
        if state is None: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi DB."); return
        if not state.get("channels"): await update.message.reply_text("Kh√¥ng c√≥ k√™nh n√†o trong danh s√°ch."); return
        message_parts = ["üìú <b>C√°c k√™nh ƒëang ƒë∆∞·ª£c theo d√µi:</b>\n"]
        for i, (channel_id, data) in enumerate(state["channels"].items(), 1):
            name = html.escape(data.get('name', 'T√™n kh√¥ng x√°c ƒë·ªãnh'))
            url = html.escape(data.get('url', '#'))
            message_parts.append(f"<b>{i}. {name}</b>\n   - Link: {url}\n   - ID: <code>{channel_id}</code>\n")
        await update.message.reply_text("\n".join(message_parts), parse_mode=ParseMode.HTML, disable_web_page_preview=True)

def run_bot():
    global application
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    application = Application.builder().token(BOT_TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("add", add_channel))
    application.add_handler(CommandHandler("remove", remove_channel))
    application.add_handler(CommandHandler("list", list_channels))
    application.add_handler(CommandHandler("resubscribeall", resubscribeall))
    
    # X√ìA B·ªé JOB_QUEUE
    
    logger.info("Bot Telegram ƒë√£ kh·ªüi ƒë·ªông v√† ƒëang ch·∫°y...")
    application.run_polling(stop_signals=None)

if __name__ == "__main__":
    if not all([JSONBIN_API_KEY, JSONBIN_BIN_ID]):
        logger.error("Thi·∫øu bi·∫øn m√¥i tr∆∞·ªùng JSONBIN_API_KEY ho·∫∑c JSONBIN_BIN_ID!")
    else:
        logger.info("Kh·ªüi ƒë·ªông lu·ªìng cho bot Telegram...")
        bot_thread = threading.Thread(target=run_bot)
        bot_thread.daemon = True
        bot_thread.start()
        # Ch·∫°y Flask ·ªü lu·ªìng ch√≠nh
        app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 8080)))