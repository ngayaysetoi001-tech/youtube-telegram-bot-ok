import logging
import feedparser
import httpx
import re
import json
import os
import asyncio
from functools import wraps
import threading
from flask import Flask, request, Response
import html
import sys
import xmltodict

from telegram import Update
from telegram.ext import Application, CommandHandler, CallbackContext
from telegram.constants import ParseMode

# --- C·∫§U H√åNH LOGGING ---
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)
# ------------------------------------

# --- C·∫§U H√åNH BOT T·ª™ BI·∫æN M√îI TR∆Ø·ªúNG ---
BOT_TOKEN = os.getenv('BOT_TOKEN')
CHAT_ID = os.getenv('CHAT_ID')
ADMIN_USER_ID_STR = os.getenv('ADMIN_USER_ID')
CALLBACK_URL = os.getenv('RENDER_EXTERNAL_URL', 'https://your-app-name.onrender.com') + "/youtube_webhook"
# ------------------------------------

if not all([BOT_TOKEN, CHAT_ID, ADMIN_USER_ID_STR]):
    logger.critical("L·ªñI: Thi·∫øu bi·∫øn m√¥i tr∆∞·ªùng b·∫Øt bu·ªôc: BOT_TOKEN, CHAT_ID, ADMIN_USER_ID")
    sys.exit(1)

ADMIN_USER_ID = int(ADMIN_USER_ID_STR)

# --- C·∫§U H√åNH JSONBIN.IO ---
JSONBIN_API_KEY = os.getenv('JSONBIN_API_KEY')
JSONBIN_BIN_ID = os.getenv('JSONBIN_BIN_ID')
JSONBIN_URL = f"https://api.jsonbin.io/v3/b/{JSONBIN_BIN_ID}"
# ------------------------------------

HUB_URL = "https://pubsubhubbub.appspot.com/subscribe"
state_lock = asyncio.Lock()
app = Flask(__name__)

# --- S·ª¨A L·ªñI: BI·∫æN TO√ÄN C·ª§C ƒê·ªÇ GIAO TI·∫æP GI·ªÆA C√ÅC LU·ªíNG ---
application: Application = None
bot_loop: asyncio.AbstractEventLoop = None
# -----------------------------------------------------------

async def load_state(client: httpx.AsyncClient):
    headers = {'X-Master-Key': JSONBIN_API_KEY}
    try:
        response = await client.get(f"{JSONBIN_URL}/latest", headers=headers, timeout=15)
        response.raise_for_status()
        return response.json().get('record', {"channels": {}})
    except httpx.RequestError as e:
        logger.error(f"L·ªói khi ƒë·ªçc tr·∫°ng th√°i: {e}")
        return None

async def save_state(client: httpx.AsyncClient, state):
    headers = {'Content-Type': 'application/json', 'X-Master-Key': JSONBIN_API_KEY}
    try:
        data_to_save = json.dumps(state, ensure_ascii=False).encode('utf-8')
        response = await client.put(JSONBIN_URL, headers=headers, content=data_to_save, timeout=15)
        response.raise_for_status()
        logger.info("ƒê√£ l∆∞u tr·∫°ng th√°i th√†nh c√¥ng l√™n JSONBin.io")
        return True
    except httpx.RequestError as e:
        logger.error(f"L·ªói khi l∆∞u tr·∫°ng th√°i l√™n JSONBin: {e}")
        return False

async def get_channel_id_from_url(client: httpx.AsyncClient, channel_url):
    try:
        response = await client.get(channel_url, timeout=15, follow_redirects=True)
        response.raise_for_status()
        match = re.search(r'"channelId":"(UC[A-Za-z0-9_-]{22})"', response.text)
        if match: return match.group(1)
        else: return None
    except httpx.RequestError as e:
        logger.error(f"L·ªói khi l·∫•y Channel ID t·ª´ {channel_url}: {e}")
        return None

def restricted(func):
    @wraps(func)
    async def wrapped(update: Update, context: CallbackContext, *args, **kwargs):
        user_id = update.effective_user.id
        if user_id != ADMIN_USER_ID:
            await update.message.reply_text("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
            return
        return await func(update, context, *args, **kwargs)
    return wrapped

async def start(update: Update, context: CallbackContext):
    await update.message.reply_text("üëã Ch√†o b·∫°n! T√¥i l√† bot th√¥ng b√°o video YouTube, phi√™n b·∫£n Webhook t·ªëc ƒë·ªô cao.")

async def help_command(update: Update, context: CallbackContext):
    await update.message.reply_text("C√°c l·ªánh: /add, /remove, /list, /resubscribeall")

async def manage_subscription(channel_id: str, mode: str = "subscribe"):
    topic_url = f"https://www.youtube.com/feeds/videos.xml?channel_id={channel_id}"
    data = {'hub.mode': mode, 'hub.topic': topic_url, 'hub.callback': CALLBACK_URL, 'hub.verify': 'async', 'hub.lease_seconds': 432000}
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(HUB_URL, data=data)
            if 200 <= response.status_code < 300:
                logger.info(f"Y√™u c·∫ßu '{mode}' cho k√™nh {channel_id} ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng.")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i y√™u c·∫ßu '{mode}' cho k√™nh {channel_id}. Status: {response.status_code}, Body: {response.text}")
                return False
        except httpx.RequestError as e:
            logger.error(f"L·ªói m·∫°ng khi g·ª≠i y√™u c·∫ßu '{mode}': {e}")
            return False

async def process_notification(xml_data: bytes):
    logger.info("ƒê√£ nh·∫≠n ƒë∆∞·ª£c th√¥ng b√°o t·ª´ Hub.")
    try:
        data = xmltodict.parse(xml_data)
        entry = data.get('feed', {}).get('entry')
        if not entry: return
        video_id, channel_id = entry.get('yt:videoId'), entry.get('yt:channelId')
        if not video_id or not channel_id: return
            
        async with httpx.AsyncClient() as client:
            async with state_lock:
                state = await load_state(client)
                if state is None or channel_id not in state.get("channels", {}): return
                last_known_id = state["channels"][channel_id].get("last_video_id")
                if last_known_id != video_id:
                    logger.info(f"Ph√°t hi·ªán video m·ªõi {video_id} cho k√™nh {channel_id}.")
                    channel_name = html.escape(state["channels"][channel_id].get('name', entry.get('author', {}).get('name')))
                    video_title, video_link = html.escape(entry.get('title')), entry.get('link', {}).get('@href')
                    message = (f"üì∫ <b>{channel_name}</b> v·ª´a ra video m·ªõi!\n\n<b>{video_title}</b>\n\n<a href='{video_link}'>Xem ngay t·∫°i ƒë√¢y</a>")
                    await application.bot.send_message(chat_id=CHAT_ID, text=message, parse_mode=ParseMode.HTML)
                    state["channels"][channel_id]["last_video_id"] = video_id
                    await save_state(client, state)
    except Exception as e:
        logger.error(f"L·ªói nghi√™m tr·ªçng khi x·ª≠ l√Ω th√¥ng b√°o: {e}", exc_info=True)

@app.route('/youtube_webhook', methods=['GET', 'POST'])
def webhook_endpoint():
    if request.method == 'GET':
        challenge = request.args.get('hub.challenge')
        if challenge:
            logger.info("X√°c th·ª±c webhook th√†nh c√¥ng v·ªõi Hub.")
            return Response(challenge, status=200, mimetype='text/plain')
        return Response("No challenge", status=400, mimetype='text/plain')
    elif request.method == 'POST':
        # --- S·ª¨A L·ªñI: S·ª¨ D·ª§NG PH∆Ø∆†NG TH·ª®C AN TO√ÄN ƒê·ªÇ G·ª¨I T√ÅC V·ª§ ---
        if bot_loop:
            asyncio.run_coroutine_threadsafe(process_notification(request.data), bot_loop)
        # -----------------------------------------------------------
        return Response("OK", status=200)

@restricted
async def add_channel(update: Update, context: CallbackContext):
    if not context.args: await update.message.reply_text("Vui l√≤ng nh·∫≠p link k√™nh ho·∫∑c Channel ID."); return
    user_input = context.args[0]
    async with httpx.AsyncClient() as client:
        async with state_lock:
            state = await load_state(client)
            if state is None: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi DB."); return
            channel_id, final_url = None, None
            if user_input.startswith("UC") and len(user_input) == 24: channel_id, final_url = user_input, f"https://www.youtube.com/channel/{user_input}"
            elif user_input.startswith("http"): final_url, channel_id = user_input, await get_channel_id_from_url(client, user_input)
            else: await update.message.reply_text("‚ùå ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá."); return
            if not channel_id: await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y Channel ID."); return
            if channel_id in state["channels"]: await update.message.reply_text("‚úÖ K√™nh ƒë√£ c√≥ trong danh s√°ch."); return
            feed = await asyncio.to_thread(feedparser.parse, f'https://www.youtube.com/feeds/videos.xml?channel_id={channel_id}')
            channel_name = feed.feed.get('title', "T√™n kh√¥ng x√°c ƒë·ªãnh")
            state["channels"][channel_id] = {"url": final_url, "name": channel_name, "last_video_id": None}
            if await save_state(client, state):
                safe_name = html.escape(channel_name)
                await update.message.reply_text(f"‚úÖ ƒê√£ th√™m k√™nh: <b>{safe_name}</b>. ƒêang ƒëƒÉng k√Ω nh·∫≠n th√¥ng b√°o...", parse_mode=ParseMode.HTML)
                if await manage_subscription(channel_id, "subscribe"): await update.message.reply_text(f"‚úÖ ƒêƒÉng k√Ω cho <b>{safe_name}</b> th√†nh c√¥ng!", parse_mode=ParseMode.HTML)
                else: await update.message.reply_text(f"‚ö†Ô∏è L·ªói khi ƒëƒÉng k√Ω cho <b>{safe_name}</b>.", parse_mode=ParseMode.HTML)
            else: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ l∆∞u thay ƒë·ªïi.")

@restricted
async def remove_channel(update: Update, context: CallbackContext):
    if not context.args: await update.message.reply_text("Vui l√≤ng nh·∫≠p link/ID c·∫ßn x√≥a."); return
    user_input = context.args[0]
    async with httpx.AsyncClient() as client:
        async with state_lock:
            state = await load_state(client)
            if state is None: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi DB."); return
            channel_id_to_remove = None
            if user_input.startswith("UC") and len(user_input) == 24: channel_id_to_remove = user_input
            elif user_input.startswith("http"): channel_id_to_remove = await get_channel_id_from_url(client, user_input)
            else: await update.message.reply_text("‚ùå ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá."); return
            if not channel_id_to_remove: await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y k√™nh."); return
            if channel_id_to_remove in state["channels"]:
                channel_name = state["channels"][channel_id_to_remove].get('name', 'K√™nh kh√¥ng r√µ t√™n')
                del state["channels"][channel_id_to_remove]
                if await save_state(client, state):
                    safe_name = html.escape(channel_name)
                    await update.message.reply_text(f"üóëÔ∏è ƒê√£ x√≥a k√™nh: <b>{safe_name}</b>.", parse_mode=ParseMode.HTML)
                    await manage_subscription(channel_id_to_remove, "unsubscribe")
                else: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ l∆∞u thay ƒë·ªïi.")
            else: await update.message.reply_text("K√™nh n√†y kh√¥ng c√≥ trong danh s√°ch.")

@restricted
async def resubscribeall(update: Update, context: CallbackContext):
    await update.message.reply_text("B·∫Øt ƒë·∫ßu qu√° tr√¨nh ƒëƒÉng k√Ω l·∫°i cho t·∫•t c·∫£ c√°c k√™nh...")
    async with httpx.AsyncClient() as client:
        state = await load_state(client)
        if state is None or not state.get("channels"): await update.message.reply_text("Kh√¥ng c√≥ k√™nh n√†o."); return
        success_count, fail_count = 0, 0
        for channel_id in state["channels"]:
            if await manage_subscription(channel_id, "subscribe"): success_count += 1
            else: fail_count += 1
            await asyncio.sleep(1)
    await update.message.reply_text(f"Ho√†n t·∫•t! Th√†nh c√¥ng: {success_count}, th·∫•t b·∫°i: {fail_count}.")

@restricted
async def list_channels(update: Update, context: CallbackContext):
    async with httpx.AsyncClient() as client:
        state = await load_state(client)
        if state is None: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi DB."); return
        if not state.get("channels"): await update.message.reply_text("Kh√¥ng c√≥ k√™nh n√†o."); return
        message_parts = ["üìú <b>C√°c k√™nh ƒëang ƒë∆∞·ª£c theo d√µi:</b>\n"]
        for i, (channel_id, data) in enumerate(state["channels"].items(), 1):
            name, url = html.escape(data.get('name', '')), html.escape(data.get('url', '#'))
            message_parts.append(f"<b>{i}. {name}</b>\n   - Link: {url}\n   - ID: <code>{channel_id}</code>\n")
        await update.message.reply_text("\n".join(message_parts), parse_mode=ParseMode.HTML, disable_web_page_preview=True)

def run_bot():
    global application, bot_loop
    # --- S·ª¨A L·ªñI: L∆ØU L·∫†I EVENT LOOP C·ª¶A BOT ---
    bot_loop = asyncio.new_event_loop()
    # -------------------------------------------
    asyncio.set_event_loop(bot_loop)
    application = Application.builder().token(BOT_TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("add", add_channel))
    application.add_handler(CommandHandler("remove", remove_channel))
    application.add_handler(CommandHandler("list", list_channels))
    application.add_handler(CommandHandler("resubscribeall", resubscribeall))
    logger.info("Bot Telegram ƒë√£ kh·ªüi ƒë·ªông v√† ƒëang ch·∫°y...")
    application.run_polling(stop_signals=None)

if __name__ == "__main__":
    if not all([JSONBIN_API_KEY, JSONBIN_BIN_ID]):
        logger.error("Thi·∫øu bi·∫øn m√¥i tr∆∞·ªùng JSONBIN_API_KEY ho·∫∑c JSONBIN_BIN_ID!")
    else:
        logger.info("Kh·ªüi ƒë·ªông lu·ªìng cho bot Telegram...")
        bot_thread = threading.Thread(target=run_bot)
        bot_thread.daemon = True
        bot_thread.start()
        app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 8080)))