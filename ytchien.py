import logging
import httpx
import re
import json
import os
import asyncio
from functools import wraps
import threading
from flask import Flask
import html
import sys

from telegram import Update
from telegram.ext import Application, CommandHandler, CallbackContext
from telegram.constants import ParseMode
from datetime import datetime, timedelta, timezone

# --- C·∫§U H√åNH LOGGING ---
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)
# ------------------------------------

# --- C·∫§U H√åNH BOT T·ª™ BI·∫æN M√îI TR∆Ø·ªúNG ---
BOT_TOKEN = os.getenv('BOT_TOKEN')
CHAT_ID = os.getenv('CHAT_ID')
ADMIN_USER_ID_STR = os.getenv('ADMIN_USER_ID')
YOUTUBE_API_KEY = os.getenv('YOUTUBE_API_KEY')
# ------------------------------------

if not all([BOT_TOKEN, CHAT_ID, ADMIN_USER_ID_STR, YOUTUBE_API_KEY]):
    logger.critical("L·ªñI: Thi·∫øu m·ªôt trong c√°c bi·∫øn m√¥i tr∆∞·ªùng b·∫Øt bu·ªôc!")
    sys.exit(1)

ADMIN_USER_ID = int(ADMIN_USER_ID_STR)
CHECK_INTERVAL = 60 # C√≥ th·ªÉ ƒë·∫∑t 60 gi√¢y v√¨ API r·∫•t r·∫ª

# --- C·∫§U H√åNH JSONBIN.IO ---
JSONBIN_API_KEY = os.getenv('JSONBIN_API_KEY')
JSONBIN_BIN_ID = os.getenv('JSONBIN_BIN_ID')
JSONBIN_URL = f"https://api.jsonbin.io/v3/b/{JSONBIN_BIN_ID}"
# ------------------------------------

state_lock = asyncio.Lock()
app = Flask(__name__)

# --- C√ÅC H√ÄM C∆† B·∫¢N ---
async def load_state(client: httpx.AsyncClient):
    headers = {'X-Master-Key': JSONBIN_API_KEY}
    try:
        response = await client.get(f"{JSONBIN_URL}/latest", headers=headers, timeout=15)
        response.raise_for_status()
        return response.json().get('record', {"channels": {}})
    except httpx.RequestError as e:
        logger.error(f"L·ªói khi ƒë·ªçc tr·∫°ng th√°i: {e}")
        return None

async def save_state(client: httpx.AsyncClient, state):
    headers = {'Content-Type': 'application/json', 'X-Master-Key': JSONBIN_API_KEY}
    try:
        data_to_save = json.dumps(state, ensure_ascii=False).encode('utf-8')
        response = await client.put(JSONBIN_URL, headers=headers, content=data_to_save, timeout=15)
        response.raise_for_status()
        logger.info("ƒê√£ l∆∞u tr·∫°ng th√°i th√†nh c√¥ng l√™n JSONBin.io")
        return True
    except httpx.RequestError as e:
        logger.error(f"L·ªói khi l∆∞u tr·∫°ng th√°i l√™n JSONBin: {e}")
        return False

def restricted(func):
    @wraps(func)
    async def wrapped(update: Update, context: CallbackContext, *args, **kwargs):
        user_id = update.effective_user.id
        if user_id != ADMIN_USER_ID:
            await update.message.reply_text("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
            return
        return await func(update, context, *args, **kwargs)
    return wrapped

async def get_channel_id_from_url(client: httpx.AsyncClient, channel_url):
    try:
        response = await client.get(channel_url, timeout=15, follow_redirects=True)
        response.raise_for_status()
        match = re.search(r'"channelId":"(UC[A-Za-z0-9_-]{22})"', response.text)
        if match: return match.group(1)
        else: return None
    except httpx.RequestError as e:
        logger.error(f"L·ªói khi l·∫•y Channel ID t·ª´ {channel_url}: {e}")
        return None

async def start(update: Update, context: CallbackContext):
    await update.message.reply_text("üëã Ch√†o b·∫°n! T√¥i l√† bot th√¥ng b√°o video YouTube, phi√™n b·∫£n API hi·ªáu su·∫•t cao.")

async def help_command(update: Update, context: CallbackContext):
    await update.message.reply_text("C√°c l·ªánh: /add, /remove, /list")

# --- H√ÄM KI·ªÇM TRA ƒê√É T·ªêI ∆ØU ---
async def youtube_check_callback(context: CallbackContext):
    logger.info("B·∫Øt ƒë·∫ßu chu k·ª≥ ki·ªÉm tra video m·ªõi b·∫±ng Playlist API...")
    async with httpx.AsyncClient() as client:
        async with state_lock:
            state = await load_state(client)
            if state is None or not state.get("channels"): return

            something_changed = False
            for channel_id, data in state["channels"].items():
                try:
                    # Chuy·ªÉn ƒë·ªïi Channel ID th√†nh Uploads Playlist ID
                    playlist_id = "UU" + channel_id[2:]
                    
                    api_url = "https://www.googleapis.com/youtube/v3/playlistItems"
                    params = {
                        'key': YOUTUBE_API_KEY,
                        'playlistId': playlist_id,
                        'part': 'snippet',
                        'maxResults': 1
                    }
                    response = await client.get(api_url, params=params)
                    if response.status_code != 200:
                        logger.error(f"L·ªói API khi ki·ªÉm tra k√™nh {channel_id}: {response.text}")
                        continue

                    api_data = response.json()
                    if not api_data.get('items'): continue
                    
                    latest_video = api_data['items'][0]
                    video_id = latest_video['snippet']['resourceId']['videoId']
                    last_known_id = data.get("last_video_id")
                    
                    # Ch·ªâ th√¥ng b√°o video m·ªõi ƒëƒÉng trong 1 ng√†y qua ƒë·ªÉ tr√°nh spam video c≈©
                    published_at_str = latest_video['snippet']['publishedAt']
                    published_at = datetime.fromisoformat(published_at_str.replace('Z', '+00:00'))
                    now = datetime.now(timezone.utc)
                    
                    if last_known_id != video_id and (now - published_at) < timedelta(days=1):
                        channel_name = html.escape(data.get('name', latest_video['snippet']['channelTitle']))
                        video_title = html.escape(latest_video['snippet']['title'])
                        video_link = f"https://www.youtube.com/watch?v={video_id}"
                        
                        message = (f"üì∫ <b>{channel_name}</b> v·ª´a ra video m·ªõi!\n\n"
                                   f"<b>{video_title}</b>\n\n"
                                   f'<a href="{video_link}">Xem ngay t·∫°i ƒë√¢y</a>')
                                   
                        await context.bot.send_message(chat_id=CHAT_ID, text=message, parse_mode=ParseMode.HTML)
                        
                        state["channels"][channel_id]["last_video_id"] = video_id
                        something_changed = True
                    # C·∫≠p nh·∫≠t ID l·∫ßn ƒë·∫ßu ƒë·ªÉ l√†m m·ªëc
                    elif last_known_id is None:
                        state["channels"][channel_id]["last_video_id"] = video_id
                        something_changed = True

                except Exception as e:
                    logger.error(f"L·ªói khi x·ª≠ l√Ω k√™nh {data.get('name', 'N/A')}: {e}", exc_info=True)
                
                await asyncio.sleep(1)

            if something_changed:
                await save_state(client, state)
    logger.info("K·∫øt th√∫c chu k·ª≥ ki·ªÉm tra.")

# --- C√ÅC L·ªÜNH COMMAND ---
@restricted
async def add_channel(update: Update, context: CallbackContext):
    if not context.args: await update.message.reply_text("Vui l√≤ng nh·∫≠p link k√™nh ho·∫∑c Channel ID."); return
    user_input = context.args[0]
    async with httpx.AsyncClient() as client:
        async with state_lock:
            state = await load_state(client)
            if state is None: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi DB."); return
            channel_id, final_url = None, None
            if user_input.startswith("UC") and len(user_input) == 24:
                channel_id, final_url = user_input, f"https://www.youtube.com/channel/{user_input}"
            elif user_input.startswith("http"):
                final_url = user_input
                channel_id = await get_channel_id_from_url(client, user_input)
            else:
                await update.message.reply_text("‚ùå ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá."); return
            if not channel_id: await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y Channel ID t·ª´ link n√†y."); return
            if channel_id in state["channels"]: await update.message.reply_text("‚úÖ K√™nh ƒë√£ c√≥ trong danh s√°ch."); return
            
            api_url = f"https://www.googleapis.com/youtube/v3/channels?part=snippet&id={channel_id}&key={YOUTUBE_API_KEY}"
            response = await client.get(api_url)
            channel_name = "T√™n kh√¥ng x√°c ƒë·ªãnh"
            if response.status_code == 200 and response.json().get('items'):
                channel_name = response.json()['items'][0]['snippet']['title']
            
            state["channels"][channel_id] = {"url": final_url, "name": channel_name, "last_video_id": None}
            if await save_state(client, state):
                safe_name = html.escape(channel_name)
                await update.message.reply_text(f"‚úÖ ƒê√£ th√™m k√™nh: <b>{safe_name}</b>.", parse_mode=ParseMode.HTML)
            else: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ l∆∞u thay ƒë·ªïi.")

@restricted
async def remove_channel(update: Update, context: CallbackContext):
    # Gi·ªØ nguy√™n nh∆∞ phi√™n b·∫£n tr∆∞·ªõc, ƒë√£ ho·∫°t ƒë·ªông t·ªët
    if not context.args: await update.message.reply_text("Vui l√≤ng nh·∫≠p link/ID c·∫ßn x√≥a."); return
    user_input = context.args[0]
    async with httpx.AsyncClient() as client:
        async with state_lock:
            state = await load_state(client);
            if state is None: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi DB."); return
            channel_id_to_remove = None
            if user_input.startswith("UC") and len(user_input) == 24: channel_id_to_remove = user_input
            elif user_input.startswith("http"): channel_id_to_remove = await get_channel_id_from_url(client, user_input)
            else: await update.message.reply_text("‚ùå ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá."); return
            if not channel_id_to_remove: await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y k√™nh."); return
            if channel_id_to_remove in state["channels"]:
                channel_name = state["channels"][channel_id_to_remove].get('name', 'K√™nh kh√¥ng r√µ t√™n')
                del state["channels"][channel_id_to_remove]
                if await save_state(client, state):
                    safe_name = html.escape(channel_name)
                    await update.message.reply_text(f"üóëÔ∏è ƒê√£ x√≥a k√™nh: <b>{safe_name}</b>.", parse_mode=ParseMode.HTML)
                else: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ l∆∞u thay ƒë·ªïi.")
            else: await update.message.reply_text("K√™nh n√†y kh√¥ng c√≥ trong danh s√°ch.")

@restricted
async def list_channels(update: Update, context: CallbackContext):
    # Gi·ªØ nguy√™n nh∆∞ phi√™n b·∫£n tr∆∞·ªõc
    async with httpx.AsyncClient() as client:
        state = await load_state(client)
        if state is None: await update.message.reply_text("‚ö†Ô∏è L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi DB."); return
        if not state.get("channels"): await update.message.reply_text("Kh√¥ng c√≥ k√™nh n√†o."); return
        message_parts = ["üìú <b>C√°c k√™nh ƒëang ƒë∆∞·ª£c theo d√µi:</b>\n"]
        for i, (channel_id, data) in enumerate(state["channels"].items(), 1):
            name, url = html.escape(data.get('name', '')), html.escape(data.get('url', '#'))
            message_parts.append(f"<b>{i}. {name}</b>\n   - Link: {url}\n   - ID: <code>{channel_id}</code>\n")
        await update.message.reply_text("\n".join(message_parts), parse_mode=ParseMode.HTML, disable_web_page_preview=True)

def run_bot():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    application = Application.builder().token(BOT_TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("add", add_channel))
    application.add_handler(CommandHandler("remove", remove_channel))
    application.add_handler(CommandHandler("list", list_channels))
    
    job_queue = application.job_queue
    job_queue.run_repeating(youtube_check_callback, interval=CHECK_INTERVAL, first=10)
    
    logger.info("Bot Telegram ƒë√£ kh·ªüi ƒë·ªông v√† ƒëang ch·∫°y...")
    application.run_polling(stop_signals=None)

# --- PH·∫¶N KH·ªûI ƒê·ªòNG CH√çNH ---
@app.route('/')
def hello_world():
    return "Telegram bot (API Version) is running in the background!"

def run_flask():
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 8080)))

if __name__ == "__main__":
    logger.info("Kh·ªüi ƒë·ªông lu·ªìng cho bot Telegram...")
    bot_thread = threading.Thread(target=run_bot)
    bot_thread.daemon = True
    bot_thread.start()
    run_flask()